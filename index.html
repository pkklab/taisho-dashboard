<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>WALL RESIDUE — WET SURFACE</title>
  <style>
    html, body { margin:0; height:100%; background:#0b0b0b; overflow:hidden; }
    canvas { display:block; width:100vw; height:100vh; }

    #stamp{
      position:fixed; left:12px; top:10px;
      font-family: ui-monospace, Menlo, Monaco, "Courier New", monospace;
      font-size:10px; letter-spacing:1px;
      color: rgba(20,20,20,0.60);
      background: rgba(245,238,227,0.40);
      border: 1px solid rgba(20,20,20,0.12);
      padding: 4px 6px;
      border-radius: 8px;
      user-select:none; pointer-events:none;
      mix-blend-mode: multiply;
      backdrop-filter: blur(2px);
    }
    #dot{
      display:inline-block; width:7px; height:7px; border-radius:999px;
      margin-right:6px; vertical-align:middle;
      background: rgba(70,55,18,0.60);
    }
    #stamp small{ opacity:0.65; margin-left:6px; }

    #err{
      position:fixed; left:12px; bottom:12px; right:12px;
      font-family: ui-monospace, Menlo, Monaco, "Courier New", monospace;
      font-size:11px; line-height:1.35;
      color: rgba(255,255,255,0.85);
      background: rgba(0,0,0,0.35);
      border: 1px solid rgba(255,255,255,0.12);
      padding: 8px 10px;
      border-radius: 10px;
      white-space: pre-wrap;
      display:none;
      pointer-events:none;
    }
  </style>
</head>
<body>
  <div id="stamp"><span id="dot"></span><span id="mode">SIM</span><small id="age"></small></div>
  <div id="err"></div>
  <canvas id="c"></canvas>

<script>
(() => {
  // ---------- error overlay ----------
  const errBox = document.getElementById("err");
  function showErr(msg){
    errBox.style.display = "block";
    errBox.textContent = msg;
  }
  window.addEventListener("error", (e)=>{
    showErr("ERROR:\n" + (e?.message || "unknown") + "\n" + (e?.filename || "") + ":" + (e?.lineno || "") );
  });
  window.addEventListener("unhandledrejection", (e)=>{
    showErr("PROMISE ERROR:\n" + (e?.reason?.message || String(e?.reason || "unknown")) );
  });

  // =========================================================
  // 0) Canvas
  // =========================================================
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha:false });

  const simCanvas = document.createElement("canvas");
  const sctx = simCanvas.getContext("2d");

  let simW = 260, simH = 160;
  let img = null, pix = null;

  // =========================================================
  // 1) Fields — 先に宣言しておく（これが今回の修正点）
  // =========================================================
  let soot = new Float32Array(0);
  let wet  = new Float32Array(0);
  let scar = new Float32Array(0);
  let tmpSoot = new Float32Array(0);
  let tmpWet  = new Float32Array(0);
  let tmpScar = new Float32Array(0);

  function allocFields(){
    const n = simW * simH;
    soot = new Float32Array(n);
    wet  = new Float32Array(n);
    scar = new Float32Array(n);
    tmpSoot = new Float32Array(n);
    tmpWet  = new Float32Array(n);
    tmpScar = new Float32Array(n);
  }

  // =========================================================
  // 2) ENV
  // =========================================================
  const ENV = {
    name: "MORIOKA",
    lat: 39.7036, lon: 141.1527,
    wind_ms: 2.0, humidity: 62, precip_mm: 0.0,
    live: false, lastUpdate: 0,
    sim: { wind_ms: 2.0, humidity: 66, precip_mm: 0.05 },
    interval_ms: 10 * 60 * 1000,
    timeout_ms: 8000,
  };

  function clamp01(x){ return Math.min(Math.max(x,0),1); }
  function lerp(a,b,t){ return a + (b-a)*t; }

  async function fetchJsonWithTimeout(url, timeoutMs){
    const ctrl = new AbortController();
    const t = setTimeout(()=>ctrl.abort(), timeoutMs);
    try{
      const res = await fetch(url, { signal: ctrl.signal, cache:"no-store" });
      if(!res.ok) throw new Error(`HTTP ${res.status}`);
      return await res.json();
    } finally { clearTimeout(t); }
  }

  function updateStamp(){
    const modeEl = document.getElementById("mode");
    const dotEl  = document.getElementById("dot");
    const ageEl  = document.getElementById("age");

    modeEl.textContent = ENV.live ? "LIVE" : "SIM";
    dotEl.style.background = ENV.live
      ? "rgba(20,60,35,0.65)"
      : "rgba(70,55,18,0.60)";

    const mins = ENV.lastUpdate ? Math.max(0, Math.floor((Date.now()-ENV.lastUpdate)/60000)) : 0;
    ageEl.textContent = ENV.lastUpdate ? `${mins}m` : "";
  }

  async function refreshEnvironment(){
    const url =
      `https://api.open-meteo.com/v1/forecast?latitude=${ENV.lat}&longitude=${ENV.lon}` +
      `&current=wind_speed_10m,relative_humidity_2m,precipitation&wind_speed_unit=ms`;

    try{
      const data = await fetchJsonWithTimeout(url, ENV.timeout_ms);
      const w = Number(data?.current?.wind_speed_10m);
      const h = Number(data?.current?.relative_humidity_2m);
      const p = Number(data?.current?.precipitation);

      const okW = Number.isFinite(w);
      const okH = Number.isFinite(h);
      const okP = Number.isFinite(p);

      ENV.wind_ms   = okW ? w : ENV.sim.wind_ms;
      ENV.humidity  = okH ? h : ENV.sim.humidity;
      ENV.precip_mm = okP ? p : ENV.sim.precip_mm;

      ENV.live = okW && okH && okP;
      ENV.lastUpdate = Date.now();
    } catch(e){
      ENV.wind_ms   = ENV.sim.wind_ms;
      ENV.humidity  = ENV.sim.humidity;
      ENV.precip_mm = ENV.sim.precip_mm;
      ENV.live = false;
      ENV.lastUpdate = Date.now();
    }
    updateStamp();
  }

  function envWindN(){ return clamp01(ENV.wind_ms / 14); }
  function envHumN(){  return clamp01((ENV.humidity - 30) / 60); }
  function envPreN(){  return clamp01(ENV.precip_mm / 2.0); }

  // =========================================================
  // 3) Noise
  // =========================================================
  function hash2D(x,y,seed){
    let h = (x|0) * 374761393 + (y|0) * 668265263 + (seed|0) * 144269;
    h = (h ^ (h >>> 13)) * 1274126177;
    h = (h ^ (h >>> 16)) >>> 0;
    return h / 4294967295;
  }
  function smoothstep(t){ return t*t*(3-2*t); }

  function valueNoise2D(x, y, seedF){
    const seed = (seedF*1000)|0;
    const xi = Math.floor(x), yi = Math.floor(y);
    const xf = x - xi, yf = y - yi;

    const a = hash2D(xi,   yi,   seed);
    const b = hash2D(xi+1, yi,   seed);
    const c = hash2D(xi,   yi+1, seed);
    const d = hash2D(xi+1, yi+1, seed);

    const u = smoothstep(xf);
    const v = smoothstep(yf);

    const ab = a + (b-a)*u;
    const cd = c + (d-c)*u;
    return ab + (cd-ab)*v;
  }

  // =========================================================
  // 4) Seed — “ずっとそこにあった”
  // =========================================================
  function seedAsAlreadyHere(){
    // ここで soot が未確保だと真っ暗になるので、確保済み前提にする
    for(let y=0; y<simH; y++){
      for(let x=0; x<simW; x++){
        const i = y*simW + x;
        const gy = y / (simH-1);

        const n1 = valueNoise2D(x*0.12, y*0.12, 19.3);
        const n2 = valueNoise2D(x*0.03, y*0.05, 71.1);
        const blob = clamp01(0.55*n1 + 0.45*n2);

        soot[i] = clamp01( (0.08 + 0.32*gy) * (0.25 + 0.75*blob) );
        wet[i]  = clamp01( 0.18 + 0.22*blob + 0.10*(1-gy) );

        const sc = valueNoise2D(x*0.06, y*0.06, 130.7);
        scar[i] = clamp01( (sc>0.76 ? (sc-0.76)*2.2 : 0) * (0.15 + 0.65*(1-gy)) );
      }
    }
  }

  // =========================================================
  // 5) Resize — ここで alloc -> seed を必ずやる
  // =========================================================
  function resize(){
    const dpr = Math.min(window.devicePixelRatio || 1, 2);
    canvas.width  = Math.floor(window.innerWidth  * dpr);
    canvas.height = Math.floor(window.innerHeight * dpr);

    const area = window.innerWidth * window.innerHeight;
    const scale = area > 1500000 ? 1.15 : area < 650000 ? 0.90 : 1.0;
    simW = Math.max(180, Math.floor(260 * scale));
    simH = Math.max(120, Math.floor(160 * scale));

    simCanvas.width = simW;
    simCanvas.height = simH;
    img = sctx.createImageData(simW, simH);
    pix = img.data;

    allocFields();
    seedAsAlreadyHere();
  }
  window.addEventListener("resize", resize, { passive:true });
  resize(); // 初回もここで全部初期化される

  // =========================================================
  // 6) Dynamics
  // =========================================================
  const STATE = {
    wetGlobal: 0.28,
    sootIn: 0.020,
    smearRate: 0.00035,
    erosionRate: 0.00018,
  };

  function updateGlobalWet(){
    const target = clamp01(0.10 + 0.55*envHumN() + 0.35*envPreN());
    STATE.wetGlobal = lerp(STATE.wetGlobal, target, 0.006);
  }

  function stepField(time){
    updateGlobalWet();

    const wn  = envWindN();
    const hum = envHumN();
    const pre = envPreN();

    const gravity = 0.06 + 0.22*STATE.wetGlobal + 0.12*pre;
    const drift = (wn - 0.5) * (0.04 + 0.06*STATE.wetGlobal);
    const spread = 0.010 + 0.040*STATE.wetGlobal;
    const dryFix = 0.0018 + (1-STATE.wetGlobal)*0.0040;

    const erosion = STATE.erosionRate * (0.35 + 0.65*wn) * (0.55 + 0.45*(1-pre));
    const smearChance = STATE.smearRate * (0.6 + 0.8*hum);

    tmpSoot.fill(0);
    tmpWet.fill(0);
    tmpScar.fill(0);

    for(let y=0; y<simH; y++){
      for(let x=0; x<simW; x++){
        const i = y*simW + x;

        const wallGrain = valueNoise2D(x*0.06, y*0.06, 250.2);
        const localWet = clamp01( 0.55*STATE.wetGlobal + 0.30*wallGrain + 0.15*wet[i] );

        const jitter = (valueNoise2D(x*0.10 + time*0.15, y*0.10, 88.8)-0.5) * 0.08;
        const dx = drift + jitter;
        const dy = gravity * (0.35 + 0.75*localWet);

        const sx = x - dx;
        const sy = y - dy;

        const x0 = Math.max(0, Math.min(simW-1, Math.floor(sx)));
        const y0 = Math.max(0, Math.min(simH-1, Math.floor(sy)));
        const x1 = Math.max(0, Math.min(simW-1, x0+1));
        const y1 = Math.max(0, Math.min(simH-1, y0+1));
        const fx = sx - x0;
        const fy = sy - y0;

        const i00 = y0*simW + x0;
        const i10 = y0*simW + x1;
        const i01 = y1*simW + x0;
        const i11 = y1*simW + x1;

        const s00 = soot[i00], s10 = soot[i10], s01 = soot[i01], s11 = soot[i11];
        const w00 = wet[i00],  w10 = wet[i10],  w01 = wet[i01],  w11 = wet[i11];
        const c00 = scar[i00], c10 = scar[i10], c01 = scar[i01], c11 = scar[i11];

        const s0 = s00 + (s10-s00)*fx;
        const s1 = s01 + (s11-s01)*fx;
        const w0 = w00 + (w10-w00)*fx;
        const w1 = w01 + (w11-w01)*fx;
        const c0 = c00 + (c10-c00)*fx;
        const c1 = c01 + (c11-c01)*fx;

        let s = s0 + (s1-s0)*fy;
        let wv = w0 + (w1-w0)*fy;
        let sc = c0 + (c1-c0)*fy;

        const nb = valueNoise2D(x*0.08, y*0.08, 401.7);
        const blur = spread * (0.35 + 0.65*localWet) * (0.50 + 0.50*nb);

        const xl = x>0 ? i-1 : i, xr = x<simW-1 ? i+1 : i;
        const yu = y>0 ? i-simW : i, yd = y<simH-1 ? i+simW : i;
        const neigh = (soot[xl] + soot[xr] + soot[yu] + soot[yd]) * 0.25;
        s = lerp(s, neigh, blur);

        s = lerp(s, soot[i], dryFix*(1-localWet));

        const er = erosion * (0.25 + 0.75*(1-localWet));
        sc = clamp01(sc + er * (0.35 + 0.65*valueNoise2D(x*0.12, y*0.12, 990.3)));
        s = clamp01(s * (1 - sc*0.12));

        wv = lerp(wv, localWet, 0.020);
        wv = clamp01(wv * (0.998 + 0.002*hum));

        tmpSoot[i] = s;
        tmpWet[i]  = wv;
        tmpScar[i] = sc;
      }
    }

    const sootIn = STATE.sootIn * (0.25 + 0.75*(0.45*hum + 0.55*(1-pre)));
    for(let y=0; y<simH; y++){
      for(let x=0; x<simW; x++){
        const i = y*simW + x;
        const gy = y / (simH-1);
        const topBias = (1-gy);
        const grain = valueNoise2D(x*0.18 + time*0.05, y*0.10, 33.1);
        const streakSeed = valueNoise2D(x*0.05, 0.0, 777.2);
        const streak = (streakSeed > 0.86) ? (streakSeed - 0.86) * 0.9 : 0.0;

        const add = sootIn * (0.20 + 0.80*grain) * (0.08 + 0.92*topBias) + streak*0.0012;
        tmpSoot[i] = clamp01(tmpSoot[i] + add * (0.35 + 0.65*(1-tmpScar[i])));

        if(Math.random() < smearChance){
          const cx = (Math.random()*simW)|0;
          const cy = (Math.random()*simH)|0;
          const r = 6 + Math.random()*18;
          if(cy > simH*0.25 && cy < simH*0.85){
            for(let yy=-r; yy<=r; yy++){
              for(let xx=-r; xx<=r; xx++){
                const nx = cx+xx, ny = cy+yy;
                if(nx<0||nx>=simW||ny<0||ny>=simH) continue;
                const d2 = xx*xx + yy*yy;
                if(d2 > r*r) continue;
                const j = ny*simW + nx;
                const fall = 1 - Math.sqrt(d2)/(r+1e-6);
                const sign = (Math.random()<0.55) ? 1 : -1;
                tmpSoot[j] = clamp01(tmpSoot[j] + sign * fall * 0.010 * (0.6 + 0.4*Math.random()));
                tmpScar[j] = clamp01(tmpScar[j] + (Math.random()*0.006) * fall);
              }
            }
          }
        }
      }
    }

    soot.set(tmpSoot);
    wet.set(tmpWet);
    scar.set(tmpScar);
  }

  // =========================================================
  // 7) Render
  // =========================================================
  const PALETTE = {
    baseR: 226, baseG: 218, baseB: 205,
    sootR: 38,  sootG: 32,  sootB: 28,
    coldR: 130, coldG: 138, coldB: 142,
  };

  function vignette(xn, yn){
    const dx = Math.abs(xn-0.5) / 0.5;
    const dy = Math.abs(yn-0.5) / 0.5;
    const d = Math.sqrt(dx*dx + dy*dy);
    return clamp01(1 - (d-0.15) / 0.95);
  }

  function render(){
    for(let y=0; y<simH; y++){
      for(let x=0; x<simW; x++){
        const i = y*simW + x;
        const p = i*4;

        const s = soot[i];
        const wv = wet[i];
        const sc = scar[i];

        const xn = x/(simW-1);
        const yn = y/(simH-1);
        const v = vignette(xn, yn);

        const dampDark = 0.88 + 0.22*wv;
        const sEff = clamp01(s * (1 - sc*0.22));
        const k = clamp01(sEff * dampDark) * 0.72;
        const cold = (wv*wv) * 0.10;

        const g1 = valueNoise2D(x*0.22, y*0.22, 501.9);
        const g2 = valueNoise2D(x*0.06, y*0.06, 911.3);
        const grain = (g1*0.6 + g2*0.4);
        const baseJit = (grain - 0.5) * 10;

        let r = (PALETTE.baseR + baseJit);
        let g = (PALETTE.baseG + baseJit);
        let b = (PALETTE.baseB + baseJit);

        r = lerp(r, PALETTE.sootR, k);
        g = lerp(g, PALETTE.sootG, k);
        b = lerp(b, PALETTE.sootB, k);

        r = lerp(r, PALETTE.coldR, cold);
        g = lerp(g, PALETTE.coldG, cold);
        b = lerp(b, PALETTE.coldB, cold);

        r = lerp(PALETTE.baseR, r, v);
        g = lerp(PALETTE.baseG, g, v);
        b = lerp(PALETTE.baseB, b, v);

        pix[p+0] = Math.max(0, Math.min(255, r|0));
        pix[p+1] = Math.max(0, Math.min(255, g|0));
        pix[p+2] = Math.max(0, Math.min(255, b|0));
        pix[p+3] = 255;
      }
    }
    sctx.putImageData(img, 0, 0);

    ctx.imageSmoothingEnabled = true;
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.drawImage(simCanvas, 0, 0, canvas.width, canvas.height);
  }

  // =========================================================
  // 8) Loop
  // =========================================================
  let last = performance.now();
  function loop(now){
    requestAnimationFrame(loop);
    const dt = Math.min(0.05, (now - last)/1000);
    last = now;

    const time = now * 0.001;
    const steps = dt > 0.030 ? 2 : (dt > 0.016 ? 1 : 0);
    for(let k=0;k<steps;k++) stepField(time);

    render();
  }

  // =========================================================
  // 9) Boot
  // =========================================================
  (async function boot(){
    updateStamp();
    await refreshEnvironment();
    setInterval(refreshEnvironment, ENV.interval_ms);
    loop(performance.now());
  })();
})();
</script>
</body>
</html>
