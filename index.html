<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>TAISHO LIVE-DATA DASHBOARD</title>

  <!-- three.js (non-module) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

  <style>
    body { margin:0; background:#000205; overflow:hidden; font-family:'Courier New', monospace; }
    #ui { position:absolute; top:20px; left:20px; color:#00f2ff; pointer-events:none; z-index:10; }
    .label { font-size:10px; letter-spacing:3px; color:#0088aa; }
    .value { font-size:24px; font-weight:bold; text-shadow:0 0 15px #00f2ff; margin-bottom:6px; }
    #status { font-size:11px; background:rgba(0,242,255,0.08); padding:8px 10px; color:#00f2ff; display:inline-block; line-height:1.6; }
    #guide { position:absolute; bottom:18px; right:18px; color:#00f2ff; font-size:10px; opacity:0.5; }
    #tiny { font-size:10px; color:#00a9b8; letter-spacing:1px; }
  </style>
</head>

<body>
  <div id="ui">
    <div class="label">OSAKA PORT REAL-TIME</div>
    <div id="tide-display" class="value">INITIALIZING...</div>

    <div class="label">TAISHO WIND SPEED</div>
    <div id="wind-display" class="value">WAITING...</div>

    <div id="status">
      STATUS: BOOTING...
      <div id="tiny">LAST UPDATE: --:-- / MODE: SIM</div>
    </div>
  </div>
  <div id="guide">DRAG: ROTATE / SCROLL: ZOOM</div>

<script>
(() => {
  // =========================
  // Config
  // =========================
  const LAT = 34.65;
  const LON = 135.43;

  const FETCH_INTERVAL_MS = 10 * 60 * 1000; // 10分
  const FETCH_TIMEOUT_MS  = 8000;           // 通信タイムアウト
  const WIND_UNIT = "ms";

  // 演出の係数
  const CORE_SCALE_BASE = 0.55;
  const CORE_SCALE_TIDE_DIV = 260; // 潮位cmで割る
  const PARTICLE_BASE_SPEED = 0.05;
  const PARTICLE_WIND_SPEED_FACTOR = 0.02;

  // 潮位のスムージング（LIVE値へ追従する速度）
  // 0.03〜0.10あたりで好みに調整OK（大きいほど追従が速い）
  const TIDE_FOLLOW = 0.06;

  // =========================
  // State
  // =========================
  let liveWindMs = 3.0;       // m/s
  let isTideLive = false;
  let isWindLive = false;
  let lastUpdateStr = "--:--";

  // Tide: APIで得た「目標値」と、画面に出す「追従値」
  let targetTideCm  = 120;
  let displayTideCm = 120;

  // fallback波（通信失敗時のシミュレーション）
  const sim = {
    tideBase: 120,
    tideAmp: 80,
    tideFreq: 0.5
  };

  // =========================
  // UI helpers
  // =========================
  const $tide   = document.getElementById("tide-display");
  const $wind   = document.getElementById("wind-display");
  const $status = document.getElementById("status");
  const $tiny   = document.getElementById("tiny");

  function setStatus(line1, modeText) {
    $status.firstChild.nodeValue = line1;
    $tiny.textContent = `LAST UPDATE: ${lastUpdateStr} / MODE: ${modeText}`;
  }

  function nowHHMM() {
    const d = new Date();
    const hh = String(d.getHours()).padStart(2, "0");
    const mm = String(d.getMinutes()).padStart(2, "0");
    return `${hh}:${mm}`;
  }

  // =========================
  // three.js setup
  // =========================
  const scene = new THREE.Scene();

  const camera = new THREE.PerspectiveCamera(
    75,
    window.innerWidth / window.innerHeight,
    0.1,
    1000
  );
  camera.position.set(0, -6, 10);

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
  document.body.appendChild(renderer.domElement);

  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.06;

  // Grid
  const grid = new THREE.GridHelper(20, 20, 0x004466, 0x001122);
  grid.rotateX(Math.PI / 2);
  scene.add(grid);

  // Outline
  const points = [
    new THREE.Vector3(0, 3, 0),
    new THREE.Vector3(-2, 1, 0),
    new THREE.Vector3(-2.5, -2, 0),
    new THREE.Vector3(0, -3.5, 0),
    new THREE.Vector3(2.5, -2, 0),
    new THREE.Vector3(2, 1, 0),
    new THREE.Vector3(0, 3, 0),
  ];
  const outline = new THREE.Line(
    new THREE.BufferGeometry().setFromPoints(points),
    new THREE.LineBasicMaterial({ color: 0x0088ff })
  );
  scene.add(outline);

  // Landmarks
  [
    { p: [0, 3, 0],     c: 0xffffff },
    { p: [0.5, 1.5, 0], c: 0xffffff },
    { p: [0, -0.5, 0],  c: 0x00ff88 },
  ].forEach(l => {
    const m = new THREE.Mesh(
      new THREE.CylinderGeometry(0.02, 0.05, 10, 8),
      new THREE.MeshBasicMaterial({ color: l.c, transparent: true, opacity: 0.3 })
    );
    m.position.set(l.p[0], l.p[1], 0);
    m.rotation.x = Math.PI / 2;
    scene.add(m);
  });

  // Particles (Wind)
  const pCount = 2000;
  const pGeo = new THREE.BufferGeometry();
  const pPos = new Float32Array(pCount * 3);
  for (let i = 0; i < pCount; i++) {
    const base = i * 3;
    pPos[base + 0] = (Math.random() - 0.5) * 20;
    pPos[base + 1] = (Math.random() - 0.5) * 20;
    pPos[base + 2] = (Math.random() - 0.5) * 20;
  }
  pGeo.setAttribute("position", new THREE.BufferAttribute(pPos, 3));
  const particles = new THREE.Points(
    pGeo,
    new THREE.PointsMaterial({ color: 0x00f2ff, size: 0.03, transparent: true, opacity: 0.5 })
  );
  scene.add(particles);

  // Core
  const core = new THREE.Mesh(
    new THREE.OctahedronGeometry(1, 0),
    new THREE.MeshPhongMaterial({ color: 0x00f2ff, wireframe: true })
  );
  scene.add(core);

  // Lights (安定版)
  const light = new THREE.PointLight(0xffffff, 1, 100);
  light.position.set(5, 5, 5);
  scene.add(light);
  scene.add(new THREE.AmbientLight(0x222222));

  // Resize
  window.addEventListener("resize", () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  // =========================
  // fetch helpers (timeout付き)
  // =========================
  async function fetchJsonWithTimeout(url, timeoutMs) {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      const res = await fetch(url, { signal: ctrl.signal, cache: "no-store" });
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      return await res.json();
    } finally {
      clearTimeout(t);
    }
  }

  function findClosestHourIndex(times, now = new Date()) {
    const nowMs = now.getTime();
    let bestIdx = 0;
    let bestDiff = Infinity;
    for (let i = 0; i < times.length; i++) {
      const t = Date.parse(times[i]);
      if (!Number.isFinite(t)) continue;
      const diff = Math.abs(t - nowMs);
      if (diff < bestDiff) {
        bestDiff = diff;
        bestIdx = i;
      }
    }
    return bestIdx;
  }

  // =========================
  // Data fetch
  // =========================
  async function fetchRealData() {
    setStatus("STATUS: CONNECTING TO TAISHO...", (isTideLive || isWindLive) ? "LIVE" : "SIM");

    // 1) Tide
    try {
      const urlTide =
        `https://marine-api.open-meteo.com/v1/marine?latitude=${LAT}&longitude=${LON}&hourly=tide_height`;
      const data = await fetchJsonWithTimeout(urlTide, FETCH_TIMEOUT_MS);

      const times = data?.hourly?.time;
      const tides = data?.hourly?.tide_height;

      if (Array.isArray(times) && Array.isArray(tides) && times.length && tides.length) {
        const idx = findClosestHourIndex(times, new Date());
        const tideM = Number(tides[idx]);
        if (Number.isFinite(tideM)) {
          targetTideCm = tideM * 100;   // ★ 目標値だけ更新（表示は追従）
          isTideLive = true;
        } else {
          isTideLive = false;
        }
      } else {
        isTideLive = false;
      }
    } catch (e) {
      console.error("Tide fetch error:", e);
      isTideLive = false;
    }

    // 2) Wind
    try {
      const urlWind =
        `https://api.open-meteo.com/v1/forecast?latitude=${LAT}&longitude=${LON}&current=wind_speed_10m&wind_speed_unit=${WIND_UNIT}`;
      const data = await fetchJsonWithTimeout(urlWind, FETCH_TIMEOUT_MS);

      const w = Number(data?.current?.wind_speed_10m);
      if (Number.isFinite(w)) {
        liveWindMs = w;
        isWindLive = true;
      } else {
        isWindLive = false;
      }
    } catch (e) {
      console.error("Wind fetch error:", e);
      isWindLive = false;
    }

    // status update
    lastUpdateStr = nowHHMM();
    const mode = (isTideLive && isWindLive) ? "FULL LIVE" : (isTideLive || isWindLive) ? "PARTIAL LIVE" : "SIM";

    if (mode === "FULL LIVE") {
      setStatus("STATUS: FULL LIVE DATA ACTIVE", "LIVE");
      $status.style.color = "#00f2ff";
    } else if (mode === "PARTIAL LIVE") {
      setStatus("STATUS: PARTIAL LIVE (FALLBACK MIX)", "MIX");
      $status.style.color = "#00f2ff";
    } else {
      setStatus("STATUS: SIMULATION MODE (NO DATA)", "SIM");
      $status.style.color = "#00f2ff";
    }
  }

  // =========================
  // Animation loop
  // =========================
  function animate() {
    requestAnimationFrame(animate);

    const time = Date.now() * 0.001;

    // --- Tide (LIVEは追従 / SIMはサイン波) ---
    let currentTideCm;
    if (isTideLive) {
      // ★ サイン波みたいな一定速度じゃなく、「目標値に向かって寄る」動きになる
      displayTideCm += (targetTideCm - displayTideCm) * TIDE_FOLLOW;
      currentTideCm = displayTideCm;
    } else {
      currentTideCm = sim.tideBase + Math.sin(time * sim.tideFreq) * sim.tideAmp;
      displayTideCm = currentTideCm;
    }

    $tide.textContent = `TIDE: ${currentTideCm.toFixed(1)} cm` + (isTideLive ? " (LIVE)" : " (SIM)");

    // --- Wind ---
    $wind.textContent = `WIND: ${liveWindMs.toFixed(1)} m/s` + (isWindLive ? " (LIVE)" : " (SIM)");

    // --- Core reacts to tide ---
    const scale = CORE_SCALE_BASE + (currentTideCm / CORE_SCALE_TIDE_DIV);
    core.scale.setScalar(scale);
    core.rotation.y += 0.01;
    core.rotation.x += 0.002;

    // --- Particles react to wind ---
    const pos = particles.geometry.attributes.position.array;
    const speed = (isWindLive ? (liveWindMs * PARTICLE_WIND_SPEED_FACTOR) : PARTICLE_BASE_SPEED);

    for (let i = 0; i < pCount; i++) {
      const base = i * 3;
      pos[base + 0] -= speed;
      if (pos[base + 0] < -10) pos[base + 0] = 10;
    }
    particles.geometry.attributes.position.needsUpdate = true;

    controls.update();
    renderer.render(scene, camera);
  }

  // =========================
  // Boot
  // =========================
  setStatus("STATUS: BOOTING...", "SIM");
  animate();        // 先に回す（fetch失敗でも止まらない）
  fetchRealData();  // 初回取得
  setInterval(fetchRealData, FETCH_INTERVAL_MS);

})();
</script>
</body>
</html>
